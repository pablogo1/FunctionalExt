namespace FunctionalExt;

public static partial class OptionExtensions
{
    /// <summary>
    /// Executes the provided mapping function against the wrapped value if option is Some. Returns None if the input option is none.
    /// </summary>
    /// <typeparam name="T">The input option enclosed type.</typeparam>
    /// <typeparam name="B">The output option enclosed type.</typeparam>
    /// <param name="option">The input option.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>An <see cref="Option{B}"/> instance.</returns>
    public static Option<B> Map<T, B>(this Option<T> option, Func<T, B> map) => option.IsSome
        ? Option<B>.Some(map(option.Value!))
        : Option<B>.None();

    /// <summary>
    /// Executes the provided function <paramref name="fn"/> if option is some. Returns None if the input option is none.
    /// </summary>
    /// <typeparam name="B"></typeparam>
    /// <param name="fn">A function to execute when option is some. It must return an Option of <typeparamref name="B"/> instance.</param>
    /// <returns>An <see cref="Option{B}"/> instance, either Some or None.</returns>
    public static Option<B> Bind<T, B>(this Option<T> option, Func<T, Option<B>> fn) => option.IsSome
        ? fn(option.Value!)
        : Option<B>.None();

    /// <summary>
    /// See <seealso cref="Bind"/>.
    /// </summary>
    /// <typeparam name="B"></typeparam>
    /// <param name="fn"></param>
    /// <returns>An <see cref="Option{B}"/> instance, either Some or None.</returns>
    public static Option<B> FlatMap<T, B>(Option<T> option, Func<T, Option<B>> fn) => option.Bind(fn);

    /// <summary>
    /// Unwraps the Option value, providing a default value in case the Option is None.
    /// </summary>
    /// <param name="orElse">The default value to return in case is None.</param>
    /// <returns>The wrapped value if Some. The provided default value if None.</returns>
    public static T IfNone<T>(this Option<T> option, T orElse) => option.IsSome ? option.Value! : orElse;

    /// <summary>
    /// Unwraps the Option value, providing a default value function (lazy) in case the Option is None.
    /// </summary>
    /// <param name="orElseFn">The function that generates the default value in case the Option is None.</param>
    /// <returns>The wrapped value if Some. The provided default value if None.</returns>
    public static T IfNone<T>(this Option<T> option, Func<T> orElseFn) => option.IsSome ? option.Value! : orElseFn();

    /// <summary>
    /// Returns the wrapped value if Some, otherwise returns the provided default value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="orElse">The default value to return in case the Option is None.</param>
    /// <returns>The wrapped value if Some. The provided default value if None.</returns>
    public static T OrElse<T>(this Option<T> option, T orElse) => option.IfNone(orElse);

    /// <summary>
    /// Unwraps the Option value, providing a default value function (lazy) in case the Option is None.
    /// </summary>
    /// <param name="orElseFn">The function that generates the default value in case the Option is None.</param>
    /// <returns>The wrapped value if Some. The provided default value if None.</returns>
    public static T OrElse<T>(this Option<T> option, Func<T> orElseFn) => option.IfNone(orElseFn);

    /// <summary>
    /// Converts an Option to a Result. If the Option is Some, it returns a successful Result with the wrapped value.
    /// If the Option is None, it returns a failed Result with the provided error.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="option">The option</param>
    /// <param name="error">The error to be included on the failed result.</param>
    /// <returns>A <see cref="Result{T, Error}"/> instance. </returns>
    public static Result<T, Error> ToResult<T>(this Option<T> option, Error error) =>
        option.IsSome
            ? Result<T, Error>.CreateSuccess(option.Value!)
            : Result<T, Error>.CreateFail(error);
        
    /// <summary>
    /// Converts an Option to a Result. If the Option is Some, it returns a successful Result with the wrapped value.
    /// If the Option is None, it returns a failed Result with the error generated by the provided function.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="option">The option</param>
    /// <param name="errorFn">A function that generates the error to be included on the failed result.</param>
    /// <returns>A <see cref="Result{T, Error}"/> instance. </returns>
    public static Result<T, Error> ToResult<T>(this Option<T> option, Func<Error> errorFn) => ToResult(option, errorFn());
}
